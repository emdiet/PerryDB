// Generated by GPT-4o1-preview (9/28/2024) (unknown fingerprint)

// test/reactive.test.ts
import { test } from 'node:test';
import assert from 'node:assert/strict';
import { Observable, Observer, Subscription, Subject } from './reactive.js';

// Test that an observer can subscribe and receive values
test('Observer should receive emitted values from Observable', () => {
  const subject = new Subject<number>();
  let receivedValue = 0;

  const observer: Observer<number> = {
    next: (value) => {
      receivedValue = value;
    },
    error: () => {},
    complete: () => {},
  };

  subject.subscribe(observer);
  subject.next(42);

  assert.strictEqual(receivedValue, 42, 'Observer did not receive the correct value');
});

// Test that multiple observers receive the same values
test('Multiple observers should receive the same emitted values', () => {
  const subject = new Subject<number>();
  let receivedValue1 = 0;
  let receivedValue2 = 0;

  const observer1: Observer<number> = {
    next: (value) => {
      receivedValue1 = value;
    },
    error: () => {},
    complete: () => {},
  };

  const observer2: Observer<number> = {
    next: (value) => {
      receivedValue2 = value;
    },
    error: () => {},
    complete: () => {},
  };

  subject.subscribe(observer1);
  subject.subscribe(observer2);
  subject.next(100);

  assert.strictEqual(receivedValue1, 100, 'Observer 1 did not receive the correct value');
  assert.strictEqual(receivedValue2, 100, 'Observer 2 did not receive the correct value');
});

// Test that an observer can unsubscribe
test('Observer should not receive values after unsubscribing', () => {
  const subject = new Subject<number>();
  let receivedValue = 0;

  const observer: Observer<number> = {
    next: (value) => {
      receivedValue = value;
    },
    error: () => {},
    complete: () => {},
  };

  const subscription = subject.subscribe(observer);
  subscription.unsubscribe();
  subject.next(50);

  assert.strictEqual(receivedValue, 0, 'Observer received value after unsubscribing');
});

// Test error handling
test('Observer should receive errors from Observable', () => {
  const subject = new Subject<number>();
  let receivedError: any = null;

  const observer: Observer<number> = {
    next: () => {},
    error: (error) => {
      receivedError = error;
    },
    complete: () => {},
  };

  subject.subscribe(observer);
  const testError = new Error('Test Error');
  subject.error(testError);

  assert.strictEqual(receivedError, testError, 'Observer did not receive the correct error');
});

// Test completion
test('Observer should be notified when Observable completes', () => {
  const subject = new Subject<number>();
  let isCompleted = false;

  const observer: Observer<number> = {
    next: () => {},
    error: () => {},
    complete: () => {
      isCompleted = true;
    },
  };

  subject.subscribe(observer);
  subject.complete();

  assert.strictEqual(isCompleted, true, 'Observer was not notified of completion');
});

// Test that no values are emitted after completion
test('Observer should not receive values after Observable completes', () => {
  const subject = new Subject<number>();
  let receivedValue = 0;

  const observer: Observer<number> = {
    next: (value) => {
      receivedValue = value;
    },
    error: () => {},
    complete: () => {},
  };

  subject.subscribe(observer);
  subject.complete();
  subject.next(999);

  assert.strictEqual(receivedValue, 0, 'Observer received value after completion');
});

// Test the pipe method for transformation
test('Observable should transform values using pipe', () => {
  const subject = new Subject<number>();
  const transformedObservable = subject.pipe((value) => value * 2);

  let receivedValue = 0;

  const observer: Observer<number> = {
    next: (value) => {
      receivedValue = value;
    },
    error: () => {},
    complete: () => {},
  };

  transformedObservable.subscribe(observer);
  subject.next(5);

  assert.strictEqual(receivedValue, 10, 'Observer did not receive transformed value');
});

// Test chaining of pipe methods
test('Observable should allow chaining of pipe methods', () => {
  const subject = new Subject<number>();
  const transformedObservable = subject
    .pipe((value) => value + 3)
    .pipe((value) => value * 2);

  let receivedValue = 0;

  const observer: Observer<number> = {
    next: (value) => {
      receivedValue = value;
    },
    error: () => {},
    complete: () => {},
  };

  transformedObservable.subscribe(observer);
  subject.next(4); // (4 + 3) * 2 = 14

  assert.strictEqual(receivedValue, 14, 'Observer did not receive correctly transformed value');
});

// Test that Subject can act as both Observable and Observer
test('Subject should act as both Observable and Observer', () => {
  const sourceSubject = new Subject<number>();
  const middleSubject = new Subject<number>();
  let receivedValue = 0;

  const observer: Observer<number> = {
    next: (value) => {
      receivedValue = value;
    },
    error: () => {},
    complete: () => {},
  };

  // Middle subject acts as an observer to source and as an observable to the observer
  sourceSubject.subscribe(middleSubject);
  middleSubject.subscribe(observer);

  sourceSubject.next(8);

  assert.strictEqual(receivedValue, 8, 'Subject did not properly relay the value');
});

// Test unsubscribe within next
test('Observer should be able to unsubscribe during next', () => {
  const subject = new Subject<number>();
  let receivedValues: number[] = [];

  const observer: Observer<number> = {
    next: (value) => {
      receivedValues.push(value);
      if (value === 2) {
        subscription.unsubscribe();
      }
    },
    error: () => {},
    complete: () => {},
  };

  const subscription = subject.subscribe(observer);

  subject.next(1);
  subject.next(2);
  subject.next(3);

  assert.deepStrictEqual(receivedValues, [1, 2], 'Observer did not unsubscribe correctly');
});
